<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HyperSpeed 5.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@300;500;700;900&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary: #00f2ff;
            --secondary: #7000ff;
            --bg-dark: #050510;
            --glass: rgba(20, 20, 35, 0.6);
        }

        body {
            font-family: 'Exo 2', sans-serif;
            background-color: var(--bg-dark);
            color: white;
            overflow-x: hidden;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(112, 0, 255, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(0, 242, 255, 0.1) 0%, transparent 20%);
        }

        /* Utilitários de Texto Neon */
        .neon-text {
            text-shadow: 0 0 10px rgba(0, 242, 255, 0.5), 0 0 20px rgba(0, 242, 255, 0.3);
        }
        .neon-border {
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.2), inset 0 0 10px rgba(0, 242, 255, 0.1);
        }

        /* Fonte Mono para números */
        .font-mono-tech {
            font-family: 'JetBrains Mono', monospace;
        }

        /* Botão START com animação avançada */
        .cyber-btn {
            background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,242,255,0.1) 100%);
            border: 1px solid var(--primary);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.2);
        }
        
        .cyber-btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: 0.5s;
        }
        
        .cyber-btn:hover::before {
            left: 100%;
        }

        .cyber-btn:hover {
            box-shadow: 0 0 40px rgba(0, 242, 255, 0.6);
            transform: scale(1.05);
            text-shadow: 0 0 8px white;
        }

        /* Canvas Wrapper */
        #visualizer-container {
            position: relative;
            width: 100%;
            height: 350px;
        }

        canvas {
            display: block;
        }

        /* Grid Background Animation */
        .grid-bg {
            background-size: 50px 50px;
            background-image: linear-gradient(to right, rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                              linear-gradient(to bottom, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            mask-image: linear-gradient(to bottom, black 40%, transparent 100%);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center relative">

    <!-- Background Grid -->
    <div class="absolute inset-0 grid-bg -z-10 pointer-events-none"></div>

    <!-- Header -->
    <header class="w-full max-w-4xl p-6 flex justify-between items-center z-10">
        <div class="flex items-center gap-3">
            <div class="w-8 h-8 border-2 border-cyan-400 rounded flex items-center justify-center relative neon-border">
                <div class="w-4 h-4 bg-cyan-400 rounded-sm animate-pulse"></div>
            </div>
            <div>
                <h1 class="text-2xl font-black tracking-widest italic bg-gradient-to-r from-cyan-400 to-purple-500 bg-clip-text text-transparent">HYPER<span class="text-white">NET</span></h1>
                <div class="text-[10px] text-gray-400 tracking-[0.3em] uppercase">Diagnostic Tool v5.0</div>
            </div>
        </div>
        
        <div class="flex flex-col items-end text-right">
            <div class="flex items-center gap-2 text-xs font-mono-tech text-cyan-300">
                <span id="connection-type">ETH/WIFI</span>
                <span class="w-2 h-2 rounded-full bg-green-500 shadow-[0_0_10px_#22c55e]"></span>
            </div>
            <div class="text-[10px] text-gray-500 mt-1" id="server-location">Detecting Server...</div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 w-full max-w-4xl flex flex-col items-center justify-start pt-4 relative z-10 px-4">
        
        <!-- Canvas Visualizer Area -->
        <div id="visualizer-container" class="mb-6">
            <canvas id="mainCanvas"></canvas>
            
            <!-- Central Display Overlay (HTML for accessibility/crisp text) -->
            <div class="absolute inset-0 flex flex-col items-center justify-center pointer-events-none">
                <div class="text-6xl md:text-8xl font-black font-mono-tech tracking-tighter text-white drop-shadow-[0_0_15px_rgba(0,242,255,0.5)] transition-all duration-100" id="main-value">
                    0.0
                </div>
                <div class="text-cyan-400 font-bold tracking-widest mt-2 text-lg" id="unit-label">MBPS</div>
                <div class="text-purple-400 text-sm font-mono-tech mt-1 h-5" id="status-text">PRONTO</div>
            </div>
        </div>

        <!-- Start Button -->
        <button id="start-btn" class="cyber-btn px-12 py-4 rounded-full text-xl font-bold tracking-widest text-cyan-100 mb-12 uppercase group">
            <span class="relative z-10 group-hover:text-white transition-colors">Iniciar Teste</span>
        </button>

        <!-- Metrics Grid -->
        <div class="w-full grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
            <!-- Ping Card -->
            <div class="bg-slate-900/50 backdrop-blur-md border border-slate-800 p-4 rounded-xl relative overflow-hidden group hover:border-cyan-500/50 transition-colors">
                <div class="absolute top-0 left-0 w-1 h-full bg-yellow-500"></div>
                <div class="text-[10px] text-gray-400 uppercase tracking-widest mb-1">Ping</div>
                <div class="text-2xl font-mono-tech text-white" id="ping-val">--</div>
                <div class="text-xs text-gray-500">ms</div>
            </div>

            <!-- Jitter Card -->
            <div class="bg-slate-900/50 backdrop-blur-md border border-slate-800 p-4 rounded-xl relative overflow-hidden hover:border-cyan-500/50 transition-colors">
                <div class="absolute top-0 left-0 w-1 h-full bg-orange-500"></div>
                <div class="text-[10px] text-gray-400 uppercase tracking-widest mb-1">Jitter</div>
                <div class="text-2xl font-mono-tech text-white" id="jitter-val">--</div>
                <div class="text-xs text-gray-500">ms</div>
            </div>

            <!-- Download Card -->
            <div class="bg-slate-900/50 backdrop-blur-md border border-slate-800 p-4 rounded-xl relative overflow-hidden hover:border-cyan-500/50 transition-colors">
                <div class="absolute top-0 left-0 w-1 h-full bg-cyan-500 shadow-[0_0_10px_cyan]"></div>
                <div class="text-[10px] text-gray-400 uppercase tracking-widest mb-1">Download</div>
                <div class="text-2xl font-mono-tech text-cyan-300" id="download-val">--</div>
                <div class="text-xs text-gray-500">Mbps</div>
            </div>

            <!-- Upload Card -->
            <div class="bg-slate-900/50 backdrop-blur-md border border-slate-800 p-4 rounded-xl relative overflow-hidden hover:border-cyan-500/50 transition-colors">
                <div class="absolute top-0 left-0 w-1 h-full bg-purple-500 shadow-[0_0_10px_purple]"></div>
                <div class="text-[10px] text-gray-400 uppercase tracking-widest mb-1">Upload</div>
                <div class="text-2xl font-mono-tech text-purple-300" id="upload-val">--</div>
                <div class="text-xs text-gray-500">Mbps</div>
            </div>
        </div>
        
        <!-- Real-time Graph Canvas -->
        <div class="w-full h-32 bg-slate-900/30 border-t border-slate-800 relative">
            <canvas id="graphCanvas" class="w-full h-full opacity-70"></canvas>
            <div class="absolute bottom-2 right-2 text-[10px] text-gray-600 font-mono-tech">REAL-TIME GRAPH</div>
        </div>

    </main>

    <footer class="w-full py-4 text-center text-[10px] text-gray-600 z-10 bg-slate-950/80 backdrop-blur">
        <p>IP: <span id="ip-address" class="text-gray-400">---.---.---.---</span> &bull; ISP: <span class="text-gray-400">Desconhecido</span> &bull; HTML5 Canvas Engine</p>
    </footer>

    <script>
        /**
         * CLASSE DE GERENCIAMENTO GRÁFICO (CANVAS)
         * Responsável por desenhar o arco, gradientes e partículas.
         */
        class SpeedVisualizer {
            constructor(canvasId, graphCanvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                
                this.graphCanvas = document.getElementById(graphCanvasId);
                this.graphCtx = this.graphCanvas.getContext('2d');

                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.speed = 0;
                this.targetSpeed = 0;
                this.particles = [];
                this.graphPoints = [];
                this.maxGraphPoints = 100;
                this.phase = 'idle'; // idle, download, upload
                
                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);
            }

            resize() {
                const parent = this.canvas.parentElement;
                this.canvas.width = parent.clientWidth;
                this.canvas.height = parent.clientHeight;
                
                const graphParent = this.graphCanvas.parentElement;
                this.graphCanvas.width = graphParent.clientWidth;
                this.graphCanvas.height = graphParent.clientHeight;
            }

            setSpeed(val, phase) {
                this.targetSpeed = val;
                this.phase = phase;
            }

            updatePhysics() {
                // Suavização do movimento do ponteiro (Lerp)
                this.speed += (this.targetSpeed - this.speed) * 0.1;

                // Adicionar ponto ao gráfico
                if (this.phase !== 'idle' && this.phase !== 'ping') {
                    this.graphPoints.push(this.speed);
                    if (this.graphPoints.length > this.maxGraphPoints) {
                        this.graphPoints.shift();
                    }
                } else if (this.phase === 'idle') {
                    this.graphPoints = [];
                }

                // Gerar Partículas se houver velocidade
                if (this.speed > 1) {
                    for(let i=0; i < Math.floor(this.speed / 20); i++) {
                        if(Math.random() > 0.5) this.addParticle();
                    }
                }

                // Atualizar partículas
                this.particles.forEach((p, index) => {
                    p.x += Math.cos(p.angle) * p.velocity;
                    p.y += Math.sin(p.angle) * p.velocity;
                    p.life -= 0.02;
                    if (p.life <= 0) this.particles.splice(index, 1);
                });
            }

            addParticle() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 1.8; // Centro do arco
                const radius = 130;
                // Partículas nascem no arco
                // Angulo vai de PI (esquerda) a 2PI (direita) -> 180 a 360 graus
                // Normalizado: 0 a 100% da velocidade mapeia o angulo
                const maxSpeed = 200; // Visual scale limit
                const normalized = Math.min(this.speed / maxSpeed, 1);
                const angle = Math.PI + (normalized * Math.PI); 

                this.particles.push({
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius,
                    angle: angle + (Math.random() - 0.5), // Dispersão
                    velocity: Math.random() * 3 + 1,
                    life: 1,
                    color: this.phase === 'upload' ? '#a855f7' : '#06b6d4'
                });
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.graphCtx.clearRect(0, 0, this.graphCanvas.width, this.graphCanvas.height);

                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 1.8;
                const radius = 130;

                // 1. Desenhar Arco de Fundo
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, Math.PI, 0); // Semicírculo
                this.ctx.lineWidth = 15;
                this.ctx.strokeStyle = '#1e293b';
                this.ctx.lineCap = 'round';
                this.ctx.stroke();

                // 2. Desenhar Arco de Progresso
                const maxSpeed = 200;
                let normalized = Math.min(this.speed / maxSpeed, 1);
                // Prevenir que seja 0 exato para estética
                if (normalized < 0.01 && this.phase !== 'idle') normalized = 0.01;

                const endAngle = Math.PI + (normalized * Math.PI);

                // Gradiente do Arco
                const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, 0);
                if (this.phase === 'upload') {
                    gradient.addColorStop(0, '#7c3aed');
                    gradient.addColorStop(1, '#d8b4fe');
                } else {
                    gradient.addColorStop(0, '#0891b2');
                    gradient.addColorStop(1, '#22d3ee');
                }

                if (this.phase !== 'idle' && this.phase !== 'ping') {
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius, Math.PI, endAngle);
                    this.ctx.lineWidth = 15;
                    this.ctx.strokeStyle = gradient;
                    this.ctx.lineCap = 'round';
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = this.phase === 'upload' ? '#a855f7' : '#06b6d4';
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0; // Reset
                }

                // 3. Desenhar Partículas
                this.particles.forEach(p => {
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, Math.random() * 2 + 1, 0, Math.PI * 2);
                    this.ctx.fillStyle = p.color;
                    this.ctx.globalAlpha = p.life;
                    this.ctx.fill();
                    this.ctx.globalAlpha = 1;
                });

                // 4. Desenhar Gráfico em Tempo Real (Canvas Inferior)
                if (this.graphPoints.length > 1) {
                    this.graphCtx.beginPath();
                    const w = this.graphCanvas.width;
                    const h = this.graphCanvas.height;
                    const step = w / this.maxGraphPoints;
                    
                    this.graphCtx.moveTo(0, h); // Start bottom left

                    this.graphPoints.forEach((pt, i) => {
                        const x = i * step;
                        const y = h - ((pt / maxSpeed) * h * 0.8); // 80% height usage
                        this.graphCtx.lineTo(x, y);
                    });

                    this.graphCtx.lineTo((this.graphPoints.length - 1) * step, h); // Close shape
                    
                    const graphGrad = this.graphCtx.createLinearGradient(0, 0, 0, h);
                    graphGrad.addColorStop(0, this.phase === 'upload' ? 'rgba(168, 85, 247, 0.4)' : 'rgba(34, 211, 238, 0.4)');
                    graphGrad.addColorStop(1, 'rgba(0,0,0,0)');
                    
                    this.graphCtx.fillStyle = graphGrad;
                    this.graphCtx.fill();
                    
                    // Linha superior
                    this.graphCtx.beginPath();
                    this.graphPoints.forEach((pt, i) => {
                        const x = i * step;
                        const y = h - ((pt / maxSpeed) * h * 0.8);
                        if(i===0) this.graphCtx.moveTo(x, y);
                        else this.graphCtx.lineTo(x, y);
                    });
                    this.graphCtx.strokeStyle = this.phase === 'upload' ? '#d8b4fe' : '#67e8f9';
                    this.graphCtx.lineWidth = 2;
                    this.graphCtx.stroke();
                }
            }

            animate() {
                this.updatePhysics();
                this.draw();
                requestAnimationFrame(this.animate);
            }
        }

        /**
         * LÓGICA DO TESTE (SIMULATION ENGINE)
         */
        class SpeedTestEngine {
            constructor() {
                this.visualizer = new SpeedVisualizer('mainCanvas', 'graphCanvas');
                
                // Elementos DOM
                this.els = {
                    mainVal: document.getElementById('main-value'),
                    unitLabel: document.getElementById('unit-label'),
                    statusText: document.getElementById('status-text'),
                    startBtn: document.getElementById('start-btn'),
                    pingVal: document.getElementById('ping-val'),
                    jitterVal: document.getElementById('jitter-val'),
                    dlVal: document.getElementById('download-val'),
                    ulVal: document.getElementById('upload-val'),
                    ip: document.getElementById('ip-address'),
                    connType: document.getElementById('connection-type'),
                    loc: document.getElementById('server-location')
                };

                this.running = false;
                this.init();
            }

            init() {
                // Tentar pegar info real de conexão
                if (navigator.connection) {
                    this.els.connType.innerText = navigator.connection.effectiveType.toUpperCase();
                }
                
                // Gerar IP fake realista
                this.els.ip.innerText = `${Math.floor(Math.random()*200+50)}.${Math.floor(Math.random()*255)}.${Math.floor(Math.random()*255)}.${Math.floor(Math.random()*255)}`;

                this.els.startBtn.addEventListener('click', () => this.run());
            }

            vibrate(pattern) {
                if (navigator.vibrate) navigator.vibrate(pattern);
            }

            async run() {
                if (this.running) return;
                this.running = true;
                
                // Reset UI
                this.els.startBtn.classList.add('opacity-0', 'pointer-events-none'); // Hide button
                this.els.pingVal.innerText = '--';
                this.els.jitterVal.innerText = '--';
                this.els.dlVal.innerText = '--';
                this.els.ulVal.innerText = '--';
                this.els.mainVal.innerText = '0.0';
                
                // 1. PING PHASE
                this.updateStatus('INICIANDO PING...', 'ping');
                this.vibrate(50);
                
                // Simulação matemática de Ping baseada em "Network Information API" se disponível
                let baseLatency = 20;
                if(navigator.connection && navigator.connection.rtt) {
                    baseLatency = navigator.connection.rtt * 0.4; // Ajuste para realidade
                }

                // Efeito Matrix de números
                for(let i=0; i<15; i++) {
                    const temp = Math.floor(Math.random() * 20 + baseLatency);
                    this.els.mainVal.innerText = temp;
                    await this.wait(60);
                }

                const finalPing = Math.floor(baseLatency + Math.random() * 10);
                const jitter = Math.floor(Math.random() * 5 + 1);
                
                this.els.pingVal.innerText = finalPing;
                this.els.jitterVal.innerText = jitter;
                this.els.mainVal.innerText = '...';

                // 2. DOWNLOAD PHASE
                await this.wait(500);
                this.updateStatus('TESTANDO DOWNLOAD', 'download');
                this.vibrate(100);

                let speed = 0;
                // Alvo de velocidade (randomizado entre 50 e 300 mbps para a demo)
                const targetDl = navigator.connection && navigator.connection.downlink 
                                ? navigator.connection.downlink * 25 // Downlink geralmente retorna MB/s ou baixo
                                : Math.random() * 200 + 100;
                
                await this.simulateCurve(targetDl, (val) => {
                    this.visualizer.setSpeed(val, 'download');
                    this.els.mainVal.innerText = val.toFixed(1);
                    this.els.dlVal.innerText = val.toFixed(1);
                });

                this.visualizer.setSpeed(0, 'idle'); // Drop needle
                await this.wait(800);

                // 3. UPLOAD PHASE
                this.updateStatus('TESTANDO UPLOAD', 'upload');
                this.vibrate(100);

                const targetUl = targetDl * (Math.random() * 0.4 + 0.1); // Upload geralmente menor
                
                await this.simulateCurve(targetUl, (val) => {
                    this.visualizer.setSpeed(val, 'upload');
                    this.els.mainVal.innerText = val.toFixed(1);
                    this.els.ulVal.innerText = val.toFixed(1);
                });

                // 4. FINISHED
                this.visualizer.setSpeed(0, 'idle');
                this.updateStatus('TESTE CONCLUÍDO', 'idle');
                this.els.mainVal.innerText = 'FIM';
                this.vibrate([100, 50, 100]);
                
                this.els.startBtn.classList.remove('opacity-0', 'pointer-events-none');
                this.els.startBtn.querySelector('span').innerText = "Testar Novamente";
                
                this.running = false;
            }

            updateStatus(text, phase) {
                this.els.statusText.innerText = text;
                this.visualizer.phase = phase;
                
                // Color grading
                if(phase === 'download') {
                    this.els.mainVal.classList.remove('text-purple-300');
                    this.els.mainVal.classList.add('text-cyan-300');
                } else if (phase === 'upload') {
                    this.els.mainVal.classList.remove('text-cyan-300');
                    this.els.mainVal.classList.add('text-purple-300');
                } else {
                    this.els.mainVal.classList.remove('text-cyan-300', 'text-purple-300');
                    this.els.mainVal.classList.add('text-white');
                }
            }

            // Simulador de Curva de Rede TCP (Slow start -> Ramp up -> Stable -> Fluctuations)
            async simulateCurve(target, callback) {
                const duration = 5000; // 5 segundos
                const start = performance.now();
                
                return new Promise(resolve => {
                    const loop = (now) => {
                        const elapsed = now - start;
                        const progress = Math.min(elapsed / duration, 1);

                        // Algoritmo de curva
                        let currentSpeed;
                        if (progress < 0.15) {
                            // Slow start
                            currentSpeed = (progress / 0.15) * (target * 0.4);
                        } else if (progress < 0.7) {
                            // Ramp up & variation
                            const noise = (Math.random() - 0.5) * (target * 0.1);
                            // Easing out cubic
                            const t = (progress - 0.15) / 0.55;
                            const factor = 1 - Math.pow(1 - t, 3);
                            currentSpeed = (target * 0.4) + (target * 0.6 * factor) + noise;
                        } else {
                            // Stable state with minor jitter
                            const noise = (Math.random() - 0.5) * (target * 0.05);
                            currentSpeed = target + noise;
                        }

                        callback(currentSpeed);

                        if(progress < 1) requestAnimationFrame(loop);
                        else resolve();
                    };
                    requestAnimationFrame(loop);
                });
            }

            wait(ms) {
                return new Promise(r => setTimeout(r, ms));
            }
        }

        // Boot
        window.addEventListener('DOMContentLoaded', () => {
            new SpeedTestEngine();
            // Simular localização
            setTimeout(() => {
                document.getElementById('server-location').innerText = "Server: São Paulo, BR (Latência Otimizada)";
            }, 1500);
        });

    </script>
</body>
</html>

